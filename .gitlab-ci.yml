variables:
  GOLANG_IMAGE: "golang:1.25.1-alpine3.22"
  IMAGE_NAME: "$CI_REGISTRY_IMAGE"
  BINARY_NAME: "helm-secrets"
  GOPATH: "$CI_PROJECT_DIR/.go"
  GOCACHE: "$CI_PROJECT_DIR/.go/cache"

stages:
  - dependencies
  - test
  - build
  - publish
  - deploy

cache:
  key: "go-modules"
  paths:
    - .go/pkg/mod
  policy: pull-push
  when: on_success

.golang_rules:
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
      changes:
        - Dockerfile
        - cmd/**/*
        - migrations/**/*
        - go.mod
        - go.sum
      when: on_success
    - if: $CI_COMMIT_BRANCH == "dev" && $CI_PIPELINE_SOURCE == "web"
      when: on_success
    - when: never

.deploy_rules:
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
      changes:
        - Dockerfile
        - cmd/**/*
        - migrations/**/*
        - go.mod
        - go.sum
      when: on_success
    - if: $CI_COMMIT_BRANCH == "dev" || $CI_PIPELINE_SOURCE == "web"
      changes:
        - .infra/**/*
      variables:
        DEPLOY_REASON: "infra_changes"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "dev" && $CI_PIPELINE_SOURCE == "web"
      when: on_success      
    - if: $CI_COMMIT_BRANCH == "main" && $CI_MERGE_REQUEST_IID
      when: on_success
    - when: never   

# Стадия 1: Загрузка и кэширование зависимостей
download_dependencies:
  stage: dependencies
  image: $GOLANG_IMAGE
  extends: .golang_rules
  script:
    - echo "Downloading Go modules..."
    - go mod download
    - echo "Verifying dependencies..."
    - go mod verify
  cache:
    key: "go-modules"
    paths:
      - .go/pkg/mod
    policy: push
    when: on_success
  artifacts:
    expire_in: 5 days
    paths:
      - .go/pkg/mod

# # Стадия 2: Тестирование и линтинг
golang_tests:
  stage: test
  image: $GOLANG_IMAGE
  variables:
    CGO_ENABLED: 1
  extends: .golang_rules
  dependencies:
    - download_dependencies
  before_script:
    - go version
    - apk add --no-cache gcc musl-dev
  script:
    - echo "Running Go tests..."
    - go test -v -race ./...
    - echo "Running Go vet..."
    - go vet ./...
    - echo "Checking code formatting..."
    - test -z $(gofmt -l ./cmd)
    - echo "Running static analysis..."
    - go run golang.org/x/vuln/cmd/govulncheck@latest ./...
  cache:
    key: "go-modules"
    paths:
      - .go/pkg/mod
    policy: pull
  allow_failure: true

golang_linters:
  stage: test
  image: golangci/golangci-lint:latest-alpine
  extends: .golang_rules
  dependencies:
    - download_dependencies
  script:
    - echo "Running golangci-lint..."
    - golangci-lint run --timeout 5m ./...
  cache:
    key: "go-modules"
    paths:
      - .go/pkg/mod
    policy: pull
  allow_failure: true

# Стадия 3: Сборка бинарного файла
build_binary:
  stage: build
  image: $GOLANG_IMAGE
  extends: .golang_rules
  dependencies:
    - download_dependencies
    - golang_tests
    - golang_linters
  before_script:
    - mkdir -p bin
  script:
    - echo "Building binary..."
    - go build -ldflags '-w -s' -a -o ./bin/$BINARY_NAME ./cmd/helm-secrets
    - echo "Binary size:"
    - ls -lh ./bin/$BINARY_NAME
    - echo "Testing binary execution..."
    - ./bin/$BINARY_NAME --version || true
  artifacts:
    name: "binary-$CI_COMMIT_REF_SLUG"
    paths:
      - bin/
    expire_in: 1 week
  cache:
    key: "go-modules"
    paths:
      - .go/pkg/mod
    policy: pull

# Стадия 4: Сборка образа
publish_image_dev:
  stage: publish
  image: quay.io/buildah/stable
  extends: .golang_rules
  variables:
    BUILDAH_FORMAT: docker
    IMAGE_NAME: "${YC_DOCKER_REGISTRY_PATH}/apps/${CI_PROJECT_NAME}"
  dependencies:
    - build_binary
  before_script:
    - |
      SAFE_COMMIT_BRANCH=$(echo "$CI_COMMIT_BRANCH" | sed 's/[^a-z0-9]/-/g')
    - echo "Using safe branch name ${SAFE_COMMIT_BRANCH}"
  script:
    - buildah build -f Dockerfile -t ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH} .
    - buildah tag ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH} ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}-${CI_PIPELINE_ID}
    - buildah tag ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH} ${IMAGE_NAME}:${CI_PIPELINE_ID}
    - cat $YC_KEY_PUSHER | buildah login --username json_key --password-stdin ${YC_DOCKER_REGISTRY_PATH}
    - buildah push ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH} docker://${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}
    - buildah push ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}-${CI_PIPELINE_ID} docker://${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}-${CI_PIPELINE_ID}
    - buildah push ${IMAGE_NAME}:${CI_PIPELINE_ID} docker://${IMAGE_NAME}:${CI_PIPELINE_ID}
    - buildah logout ${YC_DOCKER_REGISTRY_PATH}

publish_image_main:
  stage: publish
  image: quay.io/buildah/stable
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_MERGE_REQUEST_IID
      when: on_success
    - when: never 
  variables:
    BUILDAH_FORMAT: docker
    IMAGE_NAME: "${YC_DOCKER_REGISTRY_PATH}/apps/${CI_PROJECT_NAME}"
  before_script:
    - |
      SAFE_COMMIT_BRANCH=$(echo "$CI_COMMIT_BRANCH" | sed 's/[^a-z0-9]/-/g')
    - echo "Using safe branch name ${SAFE_COMMIT_BRANCH}"
  script:
    - cat $YC_KEY_PUSHER | buildah login --username json_key --password-stdin ${YC_DOCKER_REGISTRY_PATH}
    - buildah pull ${IMAGE_NAME}:dev
    - buildah tag ${IMAGE_NAME}:dev ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}
    - buildah tag ${IMAGE_NAME}:dev ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}-${CI_PIPELINE_ID}
    - buildah tag ${IMAGE_NAME}:dev ${IMAGE_NAME}:${CI_PIPELINE_ID}
    - buildah push ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH} docker://${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}
    - buildah push ${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}-${CI_PIPELINE_ID} docker://${IMAGE_NAME}:${SAFE_COMMIT_BRANCH}-${CI_PIPELINE_ID}
    - buildah push ${IMAGE_NAME}:${CI_PIPELINE_ID} docker://${IMAGE_NAME}:${CI_PIPELINE_ID}
    - buildah logout ${YC_DOCKER_REGISTRY_PATH}

# Стадия 5: Установка приложения

deploy:
  stage: deploy
  image: 
    name: alpine/helm:3.19
    entrypoint: [""]
  variables:
    GIT_STRATEGY: clone
    IMAGE_NAME: "${YC_DOCKER_REGISTRY_PATH}/apps/${CI_PROJECT_NAME}"
  extends: .deploy_rules
  environment:
    name: $CI_COMMIT_BRANCH
    url: "https://app-$CI_COMMIT_BRANCH.${INGRESS_HOST}"
  before_script:
    # Обновляем пакеты и устанавливаем зависимости
    - apk update
    - apk add --no-cache gnupg git curl gpgme
    # Устанавливаем SOPS
    - |
      if ! command -v sops &> /dev/null; then
        echo "Installing SOPS..."
        curl -Lo /usr/local/bin/sops https://github.com/mozilla/sops/releases/download/v3.7.1/sops-v3.7.1.linux
        chmod +x /usr/local/bin/sops
      fi
    # Устанавливаем helm-secrets plugin
    - |
      if ! helm plugin list | grep -q secrets; then
        echo "Installing helm-secrets plugin..."
        helm plugin install https://github.com/jkroepke/helm-secrets --version v4.6.10
      fi
  script:
    # Проверяем наличие переменной с GPG ключом
    - |
      if [ -z "${GPG_PRIVATE_KEY}" ]; then
        echo "Error: GPG_PRIVATE_KEY variable is not set"
        exit 1
      fi
    # Импортируем GPG ключ
    - gpg --armor --import ${GPG_PRIVATE_KEY}
    # Проверяем успешность импорта
    - |
      if ! gpg --list-secret-keys --keyid-format LONG; then
        echo "Error: Failed to import GPG key"
        exit 1
      fi
    # Устанавливаем или обновляем релиз
    - cd .infra
    - |
      if [ "$DEPLOY_REASON" = "infra_changes" ]; then
        echo "✅ Job запущен из-за изменений в .infra"
        DEPLOY_TAG="${CI_COMMIT_BRANCH}"
      else
        DEPLOY_TAG="${CI_PIPELINE_ID}"
      fi
    - helm secrets upgrade --install -n ${CI_COMMIT_BRANCH} helm-secret ./chart -f values.yaml -f secrets.${CI_COMMIT_BRANCH}.yaml --set image.repository=${IMAGE_NAME} --set image.tag=${DEPLOY_TAG} --set ingress.hosts[0].host=${CI_COMMIT_BRANCH}.${INGRESS_HOST} --kube-insecure-skip-tls-verify
    # Проверяем статус установки
    - helm status helm-secret -n ${CI_COMMIT_BRANCH} --kube-insecure-skip-tls-verify
  after_script:
    # Безопасно очищаем GPG ключи
    - |
      if [ -n "$(gpg --list-secret-keys --with-colons | grep '^sec:')" ]; then
        gpg --batch --yes --delete-secret-keys $(gpg --list-secret-keys --with-colons | grep '^sec:' | cut -d: -f5)
        echo "GPG keys cleaned up"
      fi